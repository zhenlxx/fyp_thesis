\chapter{Monads}
\section{Overview}
\subsection{Side effect}


\subsection{Monad}








\section{Haskell and Category Theory}
Category theory is a general theory that examine and organize mathematical object like set ,function,function domains Cartesian-set.

A Category $C $ in category theory is defined below :
\begin{enumerate}
\item a collection of objects 
\item a collection of arrows (often call morphism) 
\item operations assigning to each arrow $f$ an object $dom\;f$,its domain ,and an object $cod\;f$,its co domain.
\item a composition operator assigning to each pair of arrows $f and g$,with $cod\;f = dom\;g$,a composite arrow $ g \circ f:dom\;f \rightarrow  cod\;g$ , satisfying the following associative law: \\
For any arrow $f: A \rightarrow B,g:B \rightarrow C,and\;h: C\rightarrow D$(with A,B,C and D not necessarily distinct),
$$h\circ (g\circ f) = (h\circ g)\circ f$$
\item for each object A, an identify arrow $id_{a}: A \rightarrow A$ satisfying the following identity law:\\
For any arrow $ f: A \rightarrow B,$ 
$$ id_{a} \circ f = f  \;and\;  f\circ id_{a} = f. $$
\end{enumerate}\cite{pierce_basic_1991}

Functions are the first member of the program in functional programming,since no size affect is not allow ,there should be a way to combine the all kinds of functions to from a new function instead of just simply chain the input output of each function as the former will generate intermediate output.


For instance ,counting the file of java source code in current directory can be written as follow:


	$$ ls-al . | grep *.txt| wc -l $$ 
	
	
To substantiate the this concept , let's use the map/fold fusion technique of Haskell as an example.

If we want to calculate the sum of the square of each element of a list eg. [1,3,4,6,7,9],the result of it is  $ 1^2+3^2+4^2+6^2+7^2+9^2=192 $.In Haskell ,we could use map and fold to address problem.

 %list_of_square = map (^2)
%sum_of_list = foldr (+) 0
%sum_of_square =   sum_of_list.list_of_square

To avoid generating intermediate output from the first function to second function, the could rewite the hold function using a single fold

The all map/fusion is is equivalent to 
$ foldr f e . map g = foldr (\\x y -> f (g x) y) e $

therefore, the 

$ sum_of_square = foldr (\\x y -> x^2 + y) 0 $





\section{Monadic Function}
\subsection{Data Type Constructor}

\subsection{Monadic Function}
A monadic function is function that produce , however,monadic function like \textbf{putStr :: String -$>$ IO ()} can not be combined using \\ \textbf{(.) :: (b -$>$ c) -$>$ (a -$>$ b) -$>$ a -$>$ c}.Monadic class constructor has tag 



\section{Monads}
In Haskell,monad is used an abstract data type constructor to represent multiple kinds of computation such as a computation that will do IO action,or a computation that has state.Those computations are in-pure because that manipulate the outside world.In Haskell.Mathematically, monads are governed by set of laws that should hold for the monadic operations [A Gentle Introduction to Haskell, Version 98]. There are two basic law in monads ,they are bind return .The Monad class is defined as follow:
\begin{hcode}
class Monad m where
  (>>=) :: m a -> (a -> m b) -> m b
  (>>) :: m a -> m b -> m b
  return :: a -> m a
  fail :: String -> m a
\end{hcode}

The return function can inject a value into monadic type.
The bind function can combine two monadic function, one should be of type \textbf{m a} and another should be of type \textbf{a -$>$ m b} .

Beside this two function,Haskell also provide other monadic operator which all derive from \textbf{return} and \textbf{bind},they are:
\begin{hexample}
liftM :: (Monad m) => (a1 -> r) -> m a1 -> m r
liftM2  :: (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
ap :: (Monad m) => m (a -> b) -> m a -> m b
(=<<) :: (Monad m) => (a -> m b) -> m a -> m b
\$ ::(m a -> m b) -> m a -> m b 
\end{hexample}

These monadic operation is define using the bind and return.For example ,liftM is defined by bind and return like 
\begin{hcode}
liftM f m1              = do { x1 <- m1; return (f x1) }
\end{hcode}
Therefore,when defining a monad,only bind and return need to be specified.

\subsubsection{Monadic Characteristic}
For all monad instance ,beside define three monadic operator ,they must apply three compulsory monad laws:

\begin{hcode}
"Left identity": return a >>= f  ≡  f a
"Right identity": m >>= return  ≡  m
"Associativity": (m >>= f) >>= g  ≡  m >>= (\x -> f x >>= g)
\end{hcode}

In monad instance ,these monad laws will become a restriction of the operation when combining monadic function using monadic operation,these restriction will be discussed in following sections.


\subsection{IO Monad}
Haskell use IO monad to limit the IO sequence.Monadic operation are used to represent IO processing pipeline,
One significant different between IO monad an other monad is that it does not provide escape function like  
\begin{hcode}
IO String ->String
\end{hcode}

\subsection{State Monad}
The State Monad is defined as follow 
\begin{hcode}
newtype State s a = State {runState :: s -> (a, s)}
\end{hcode}



\subsection{List Monad}
Haskell try to use list monad to represent a calculation that return multiple result.


\section{Using Monad Operator to Combine Monadic Function}

\section{Type system in Haskell}
\section{Do Notation }
The do notation is a syntax sugar to write monadic operation especially bind in a imperative way ,to be more specified,only monadic function with the same return type can write together.An IO action that return \textbf{IO ()} can not put with and state monadic function that return \textbf{State s a}.

To write a get line and put line logic using bind, the sequence of IO is guaranteed by monad laws.
\begin{hcode}
 getLine >>= (\x -> putStrLn x)
\end{hcode}


Following code shows that the same functionalities are written using do-notation,which shows a strong similarity to a imperative language.
\begin{hcode}
do line <- getLine 
   putStrLn line
\end{hcode}


